# -*- coding: utf-8 -*-
"""백준 백트래킹

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/105YhPztsirL_dwPBvX4P77ZFIrsZ7BSp
"""

#15649번 N과 M(1)
n,m = input().split()
n = int(n)
m = int(m)

visit = [0]*(n+1)
arr = [0]*(m+1)

def is_not_duplicate(num) : 
  if visit[num] == 0 : 
    return True
  else : 
    return False

def check(x) :
  if x == m+1 : 
    for i in range(1,m+1) : 
      print(arr[i], end=' ')
    print()
  else : 
    for i in range(1,n+1) : 
      if is_not_duplicate(i) : 
        visit[i] = 1
        arr[x] = i
        check(x+1)
        arr[x] = 0
        visit[i] = 0

check(1)

#15650번 N과 M(2)
n,m = input().split()
n = int(n)
m = int(m)

arr = [0]*(m+1)

def check(x) :
  if x == m+1 : 
    for i in range(1,m+1) : 
      print(arr[i], end=' ')
    print()
  else : 
    for i in range(1,n+1) : 
      if max(arr) < i : 
        arr[x] = i
        check(x+1)
        arr[x] = 0

check(1)

#15651번 N과 M(3)
n,m = input().split()
n = int(n)
m = int(m)

arr = [0]*(m+1)

def check(x) :
  if x == m+1 : 
    for i in range(1,m+1) : 
      print(arr[i], end=' ')
    print()
  else : 
    for i in range(1,n+1) : 
      arr[x] = i
      check(x+1)
      arr[x] = 0

check(1)

#15652번 N과 M(4)
n,m = input().split()
n = int(n)
m = int(m)

arr = [0]*(m+1)

def check(x) :
  if x == m+1 : 
    for i in range(1,m+1) : 
      print(arr[i], end=' ')
    print()
  else : 
    for i in range(1,n+1) : 
      if max(arr) <= i : 
        arr[x] = i
        check(x+1)
        arr[x] = 0

check(1)

#9663번 N-Queen
n = int(input()) 
count = 0
arr = [0]*(n+1)
arr[0] = 100

def is_queen_no_die(arr, i) : # 새로 들어오는 퀸의 위치가 죽으면 False를 반환
  new_queen = arr.index(0)
  j = 1
  while arr[j] : #퀸이 존재하는 배열까지만 진행
    if arr[j] == i or abs(j - new_queen) == abs(arr[j] - i) : #퀸이 죽는 경우
      return False
    j += 1
  return True

def check(x) :
  if x == n+1 : 
    global count
    count += 1   
  else : 
    for i in range(1,n+1) :
      if x == 1 :  #첫 번째 퀸은 검사할 필요가 없음
        if n%2 == 0 and i > n//2 : # n이 짝수일때는 첫 번째 퀸을 반까지만 진행하고 나온 count값에 두배한다.
          break
        arr[x] = i
        check(x+1)
        arr[x] = 0
      elif is_queen_no_die(arr,i) : #퀸이 죽을 경우 수행하지 않음
        arr[x] = i
        check(x+1)
        arr[x] = 0

check(1)
if n%2 == 0 :
  print(count*2)
else : print(count)

#2580번 스도쿠
import sys
#input = sys.stdin.readline
board = [[0]*9 for i in range(9)]
for i in range(9) : 
  board[i][0],board[i][1],board[i][2],board[i][3],board[i][4],board[i][5],board[i][6],board[i][7],board[i][8] = map(int,input().split())

empty = [] #빈칸 좌표를 저장
for i in range(9) : 
  for j in range(9) :
    if board[i][j] == 0 : 
      empty.append([i,j])

def can_fill_empty(point, i) : #point는 빈칸의 좌표, i는 빈칸에 들어갈 숫자 
  if i in board[point[0]] : #행에 같은 숫자가 있으면 false
    return False
  for x in range(9) : 
    if board[x][point[1]] == i : #열에 같은 숫자가 있으면 false
      return False
  start_x = point[0]-(point[0]%3)
  start_y = point[1]-(point[1]%3)
  for x in range(start_x,start_x+3) : #정사각형에 같은 숫자가 있으면 false
    for y in range(start_y,start_y+3) : 
      if board[x][y] == i :
        return False
  return True

def check(x) :
  if x == len(empty) : #답 출력
    for i in range(9) : 
      for j in range(9) : 
        print(board[i][j],end=' ')
      print()
    sys.exit() #답을 한번만 출력하기위해 프로그램 강제 종료
  else : 
    for i in range(1,10) : 
      if can_fill_empty(empty[x],i): #빈칸을 채우는 조건에 만족하면.
        board[empty[x][0]][empty[x][1]] = i
        check(x+1)
        board[empty[x][0]][empty[x][1]] = 0

check(0)

#14888번 연산자 끼워넣기
