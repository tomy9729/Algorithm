# -*- coding: utf-8 -*-
"""백준 단계별로 문제풀기 동적계획법1

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/1ONK34WBW7mbluEMinkNo-sgQCB5fdJjb
"""

#1003번 피보나치 함수
fibonacci_arr = [0]*41

def fibonacci(n) :
  global count
  global fibonacci_arr
  if n == 0 :
    count[0] += 1 
    return 0
  elif n == 1 :
    count[1] += 1 
    return 1
  else : 
    if fibonacci_arr[n] == 0 : #불필요한 재귀함수를 막기 위함
      fibonacci_arr[n] = fibonacci(n-1) + fibonacci(n-2) #값을 배열에 저장함
    return fibonacci_arr[n]

count = [0]*2
T = int(input())
for i in range(T) :
  count[0] = 0
  count[1] = 0
  x = int(input())
  if x == 0 : 
    print("1 0")
  elif x == 1 :
    print("0 1")
  elif x == 2 :
    print("1 1")
  else :
    fibonacci(x)
    print("{} {}".format(fibonacci_arr[x-1],fibonacci_arr[x]))

#9184번 신나는 함수 실행
abc = [[[0]*21 for i in range(21)] for j in range(21)]

def w(a,b,c) : 
  if a <= 0 or b <= 0 or c <= 0 :
    return 1
  if a > 20 or b > 20 or c > 20 :
    if abc[20][20][20] == 0 :  
      abc[20][20][20] = w(20,20,20)
    return abc[20][20][20]

  if abc[a][b][c] :
    return abc[a][b][c]
  if a < b and b < c : 
    abc[a][b][c] =  w(a,b,c-1) + w(a,b-1,c-1) - w(a,b-1,c)
    return abc[a][b][c]

  abc[a][b][c] = w(a-1,b,c) + w(a-1,b-1,c) + w(a-1,b,c-1) - w(a-1,b-1,c-1)
  return abc[a][b][c]

while True :
  a,b,c = map(int,input().split())
  if a == -1 and b == -1 and c == -1 : 
    break
  print("w(%d, %d, %d) = %d"%(a,b,c,w(a,b,c)))

#1904번 01타일
n = int(input())

tile_num = [0]*1000001
tile_num[1] = 1
tile_num[2] = 2

for i in range(3, n+1) : 
  tile_num[i] = (tile_num[i-1] + tile_num[i-2])%15746

print(tile_num[n])

#9641번 파도반 수열

T = int(input())
p = [0]*101
p[1] = 1
p[2] = 1
p[3] = 1
p[4] = 2
p[5] = 2

for i in range(6,101) : 
  p[i] = p[i-1] + p[i-5]

for i in range(T) : 
  x = int(input())
  print(p[x])

#1149번 RGB거리 - 재귀함수 + 동적계획
import sys
sys.setrecursionlimit(10**6) 
n = int(input())
home = [0]*1001
color = [[0]*3 for i in range(1001)]
min_point = [[0]*3 for i in range(1001)]

for i in range(1,n+1) : 
  color[i] = list(map(int,input().split()))

def paint_home(x,color_num) : #x번째 집을 칠할 때
  global color
  global min_point
  if x == 1:
    return color[1][color_num]
  if color_num == 0 : 
    if min_point[x][0] == 0 : 
      min_point[x][0] = color[x][0] + min(paint_home(x-1,1),paint_home(x-1,2))
    return min_point[x][0]
  elif color_num == 1 : 
    if min_point[x][1] == 0 :
      min_point[x][1] = color[x][1] + min(paint_home(x-1,0),paint_home(x-1,2))
    return min_point[x][1]
  elif color_num == 2 : 
    if min_point[x][2] == 0:
      min_point[x][2] = color[x][2] + min(paint_home(x-1,0),paint_home(x-1,1))
    return min_point[x][2]

print(min(paint_home(n,0),paint_home(n,1),paint_home(n,2)))

#1149번 RGB거리 - 반복문 + 동적계획
n = int(input())
min_point = [[0]*3 for i in range(1001)] #최솟값

min_point[1] = list(map(int,input().split()))
for x in range(2,n+1) :
  r,g,b = map(int,input().split())
  min_point[x][0] = r + min(min_point[x-1][1],min_point[x-1][2]) # x번 째 집에 빨간색을 칠하는 경우
  min_point[x][1] = g + min(min_point[x-1][0],min_point[x-1][2]) # x번 째 집에 초록색을 칠하는 경우
  min_point[x][2] = b + min(min_point[x-1][0],min_point[x-1][1]) # x번 째 집에 파란색을 칠하는 경우

print(min(min_point[n]))

#1932번 정수 삼각형 - 재귀 + 동적계획
n = int(input())
triangle = [[0]*n for i in range(n)]
for i in range(n) :
  triangle[i] = list(map(int,input().split()))
max_point = [[0]*n for i in range(n)]

def select_num(floor, num) : 
  global triangle
  if max_point[floor][num] : 
    return max_point[floor][num]
  if floor == 0 : 
    max_point[floor][num] = triangle[floor][num]
    return max_point[floor][num] 
  if num == 0 : 
    max_point[floor][num] = triangle[floor][num] + select_num(floor-1,num)
    return max_point[floor][num]
  if num == floor :
    max_point[floor][num] = triangle[floor][num] + select_num(floor -1,num-1)
    return max_point[floor][num] 
  max_point[floor][num] = max(triangle[floor][num] + select_num(floor - 1, num-1),triangle[floor][num] + select_num(floor - 1 ,num))
  return max_point[floor][num]

result = []
for i in range(n) :
  result.append(select_num(n-1,i))
print(max(result))

#1932번 정수 삼각형 - 반복문 + 동적계획
n = int(input())
triangle = [[0]*n for i in range(n)]
for i in range(n) :
  triangle[i] = list(map(int,input().split()))
max_point = [[0]*n for i in range(n)]

max_point[0][0] = triangle[0][0]
for i in range(1,n) : 
  max_point[i][0] = triangle[i][0] + max_point[i-1][0]
  max_point[i][i] = triangle[i][i] + max_point[i-1][i-1]
  for j in range(1,i) : 
    max_point[i][j] = triangle[i][j] + max(max_point[i-1][j-1],max_point[i-1][j])

print(max(max_point[n-1]))

#2579번 계단 오르기
n = int(input()) 
step = [] #계단
for i in range(n) : 
  step.append(int(input()))
point = [False]*n
if n == 1 : #계단이 하나
   point[0] = step[0]
elif n == 2 : #계단이 둘
  point[1] = step[0] + step[1]
else :  #계단이 셋 이상
  point[0] = step[0]
  point[1] = step[0] + step[1]
  point[2] = max(step[1]+step[2],step[0]+step[2])
  for i in range(3, n) : 
    point[i] = step[i] + max(point[i-2], point[i-3] + step[i-1])

print(point[n-1])

#1463번 1로 만들기
n = int(input())
count = 0
min_count = [0]*(n+1)
def cal(n, count) : #재귀함수로 풀 경우 Recursion error 발생, 해답이 나오긴한다.
  global min_count
  if min_count[n] : 
    return min_count[n]
  if n == 1 : 
    return count
  if n % 6 == 0 : 
    min_count[n] = min(cal(n//3,count+1),cal(n//2,count+1),cal(n-1,count+1))
    return  min_count[n]
  if n % 3 == 0 : 
    min_count[n] = min(cal(n//3,count+1),cal(n-1,count+1))
    return  min_count[n]
  if n % 2 == 0 :
    min_count[n] = min(cal(n//2, count+1),cal(n-1,count+1))
    return  min_count[n]
  min_count[n] = cal(n-1,count+1)
  return min_count[n]

min_count[1] = 0
for i in range(2,n+1) :
  if i % 6 == 0 : # 6의 배수일 때, 3으로 나눈 경우/2로 나눈 경우/1을 뺀 경우 중 최솟값
    min_count[i] = 1 + min(min_count[i//3],min_count[i//2],min_count[i-1]) 
    continue
  if i % 3 == 0 : # 3의 배수일 때, 3으로 나눈 경우/1을 뺀 경우 중 최솟값
    min_count[i] = 1 + min(min_count[i//3],min_count[i-1])
    continue
  if i % 2 == 0 : # 2의 배수 일 때, 2로 나눈 경우, 1을 뺀 경우 중 최솟값
    min_count[i] = 1 + min(min_count[i//2],min_count[i-1])
    continue
  min_count[i] = min_count[i-1] +1 # 2,3의 배수가 아닌경우 그냥 1을 뺀다

#print(cal(n,0))  # 재귀함수로 풀 경우 답 출력
print(min_count[n])
