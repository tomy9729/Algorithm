# -*- coding: utf-8 -*-
"""백준 단계별로 문제풀기 동적계획법1

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/1ONK34WBW7mbluEMinkNo-sgQCB5fdJjb
"""

#1003번 피보나치 함수
fibonacci_arr = [0]*41

def fibonacci(n) :
  global count
  global fibonacci_arr
  if n == 0 :
    count[0] += 1 
    return 0
  elif n == 1 :
    count[1] += 1 
    return 1
  else : 
    if fibonacci_arr[n] == 0 : #불필요한 재귀함수를 막기 위함
      fibonacci_arr[n] = fibonacci(n-1) + fibonacci(n-2) #값을 배열에 저장함
    return fibonacci_arr[n]

count = [0]*2
T = int(input())
for i in range(T) :
  count[0] = 0
  count[1] = 0
  x = int(input())
  if x == 0 : 
    print("1 0")
  elif x == 1 :
    print("0 1")
  elif x == 2 :
    print("1 1")
  else :
    fibonacci(x)
    print("{} {}".format(fibonacci_arr[x-1],fibonacci_arr[x]))

#9184번 신나는 함수 실행
abc = [[[0]*21 for i in range(21)] for j in range(21)]

def w(a,b,c) : 
  if a <= 0 or b <= 0 or c <= 0 :
    return 1
  if a > 20 or b > 20 or c > 20 :
    if abc[20][20][20] == 0 :  
      abc[20][20][20] = w(20,20,20)
    return abc[20][20][20]

  if abc[a][b][c] :
    return abc[a][b][c]
  if a < b and b < c : 
    abc[a][b][c] =  w(a,b,c-1) + w(a,b-1,c-1) - w(a,b-1,c)
    return abc[a][b][c]

  abc[a][b][c] = w(a-1,b,c) + w(a-1,b-1,c) + w(a-1,b,c-1) - w(a-1,b-1,c-1)
  return abc[a][b][c]

while True :
  a,b,c = map(int,input().split())
  if a == -1 and b == -1 and c == -1 : 
    break
  print("w(%d, %d, %d) = %d"%(a,b,c,w(a,b,c)))

#1904번 01타일
n = int(input())

tile_num = [0]*1000001
tile_num[1] = 1
tile_num[2] = 2

for i in range(3, n+1) : 
  tile_num[i] = (tile_num[i-1] + tile_num[i-2])%15746

print(tile_num[n])

#9641번 파도반 수열

T = int(input())
p = [0]*101
p[1] = 1
p[2] = 1
p[3] = 1
p[4] = 2
p[5] = 2

for i in range(6,101) : 
  p[i] = p[i-1] + p[i-5]

for i in range(T) : 
  x = int(input())
  print(p[x])

#1149번 RGB거리 - 재귀함수 + 동적계획
import sys
sys.setrecursionlimit(10**6) 
n = int(input())
home = [0]*1001
color = [[0]*3 for i in range(1001)]
min_point = [[0]*3 for i in range(1001)]

for i in range(1,n+1) : 
  color[i] = list(map(int,input().split()))

def paint_home(x,color_num) : #x번째 집을 칠할 때
  global color
  global min_point
  if x == 1:
    return color[1][color_num]
  if color_num == 0 : 
    if min_point[x][0] == 0 : 
      min_point[x][0] = color[x][0] + min(paint_home(x-1,1),paint_home(x-1,2))
    return min_point[x][0]
  elif color_num == 1 : 
    if min_point[x][1] == 0 :
      min_point[x][1] = color[x][1] + min(paint_home(x-1,0),paint_home(x-1,2))
    return min_point[x][1]
  elif color_num == 2 : 
    if min_point[x][2] == 0:
      min_point[x][2] = color[x][2] + min(paint_home(x-1,0),paint_home(x-1,1))
    return min_point[x][2]

print(min(paint_home(n,0),paint_home(n,1),paint_home(n,2)))

#1149번 RGB거리 - 반복문 + 동적계획
n = int(input())
min_point = [[0]*3 for i in range(1001)] #최솟값

min_point[1] = list(map(int,input().split()))
for x in range(2,n+1) :
  r,g,b = map(int,input().split())
  min_point[x][0] = r + min(min_point[x-1][1],min_point[x-1][2]) # x번 째 집에 빨간색을 칠하는 경우
  min_point[x][1] = g + min(min_point[x-1][0],min_point[x-1][2]) # x번 째 집에 초록색을 칠하는 경우
  min_point[x][2] = b + min(min_point[x-1][0],min_point[x-1][1]) # x번 째 집에 파란색을 칠하는 경우

print(min(min_point[n]))

#1932번 정수 삼각형 - 재귀 + 동적계획
n = int(input())
triangle = [[0]*n for i in range(n)]
for i in range(n) :
  triangle[i] = list(map(int,input().split()))
max_point = [[0]*n for i in range(n)]

def select_num(floor, num) : 
  global triangle
  if max_point[floor][num] : 
    return max_point[floor][num]
  if floor == 0 : 
    max_point[floor][num] = triangle[floor][num]
    return max_point[floor][num] 
  if num == 0 : 
    max_point[floor][num] = triangle[floor][num] + select_num(floor-1,num)
    return max_point[floor][num]
  if num == floor :
    max_point[floor][num] = triangle[floor][num] + select_num(floor -1,num-1)
    return max_point[floor][num] 
  max_point[floor][num] = max(triangle[floor][num] + select_num(floor - 1, num-1),triangle[floor][num] + select_num(floor - 1 ,num))
  return max_point[floor][num]

result = []
for i in range(n) :
  result.append(select_num(n-1,i))
print(max(result))

#1932번 정수 삼각형 - 반복문 + 동적계획
n = int(input())
triangle = [[0]*n for i in range(n)]
for i in range(n) :
  triangle[i] = list(map(int,input().split()))
max_point = [[0]*n for i in range(n)]

max_point[0][0] = triangle[0][0]
for i in range(1,n) : 
  max_point[i][0] = triangle[i][0] + max_point[i-1][0]
  max_point[i][i] = triangle[i][i] + max_point[i-1][i-1]
  for j in range(1,i) : 
    max_point[i][j] = triangle[i][j] + max(max_point[i-1][j-1],max_point[i-1][j])

print(max(max_point[n-1]))

#2579번 계단 오르기
n = int(input()) 
step = [] #계단
for i in range(n) : 
  step.append(int(input()))
point = [False]*n
if n == 1 : #계단이 하나
   point[0] = step[0]
elif n == 2 : #계단이 둘
  point[1] = step[0] + step[1]
else :  #계단이 셋 이상
  point[0] = step[0]
  point[1] = step[0] + step[1]
  point[2] = max(step[1]+step[2],step[0]+step[2])
  for i in range(3, n) : 
    point[i] = step[i] + max(point[i-2], point[i-3] + step[i-1])

print(point[n-1])

#1463번 1로 만들기
n = int(input())
count = 0
min_count = [0]*(n+1)
def cal(n, count) : #재귀함수로 풀 경우 Recursion error 발생, 해답이 나오긴한다.
  global min_count
  if min_count[n] : 
    return min_count[n]
  if n == 1 : 
    return count
  if n % 6 == 0 : 
    min_count[n] = min(cal(n//3,count+1),cal(n//2,count+1),cal(n-1,count+1))
    return  min_count[n]
  if n % 3 == 0 : 
    min_count[n] = min(cal(n//3,count+1),cal(n-1,count+1))
    return  min_count[n]
  if n % 2 == 0 :
    min_count[n] = min(cal(n//2, count+1),cal(n-1,count+1))
    return  min_count[n]
  min_count[n] = cal(n-1,count+1)
  return min_count[n]

min_count[1] = 0
for i in range(2,n+1) :
  if i % 6 == 0 : # 6의 배수일 때, 3으로 나눈 경우/2로 나눈 경우/1을 뺀 경우 중 최솟값
    min_count[i] = 1 + min(min_count[i//3],min_count[i//2],min_count[i-1]) 
    continue
  if i % 3 == 0 : # 3의 배수일 때, 3으로 나눈 경우/1을 뺀 경우 중 최솟값
    min_count[i] = 1 + min(min_count[i//3],min_count[i-1])
    continue
  if i % 2 == 0 : # 2의 배수 일 때, 2로 나눈 경우, 1을 뺀 경우 중 최솟값
    min_count[i] = 1 + min(min_count[i//2],min_count[i-1])
    continue
  min_count[i] = min_count[i-1] +1 # 2,3의 배수가 아닌경우 그냥 1을 뺀다

#print(cal(n,0))  # 재귀함수로 풀 경우 답 출력
print(min_count[n])

#10844번 쉬운 계단 수
n = int(input())

step_num = [[0]*(10) for i in range(n+1)]
for i in range(1,10) : 
  step_num[1][i] = 1

for i in range(2,n+1) : 
  step_num[i][0] = step_num[i-1][1] # 1의 자리가 0인 수를 만드는 것은 1의 자리가 1인 수
  step_num[i][9] = step_num[i-1][8] # 1의 자리가 9인 수를 만드는 것은 1의 자리가 8인 수
  for j in range(1,9) : 
    step_num[i][j] = (step_num[i-1][j-1] + step_num[i-1][j+1])%1000000000 # 1의 자리가 j인 수를 만드는 것은 1의 자리가 j-1, j+1인 수

print(sum(step_num[n])%1000000000)

#2156번 포도주 시식
n = int(input()) 
podoju = [] #포도주
for i in range(n) : 
  podoju.append(int(input()))
point = [False]*n

if n == 1 : #포도주 하나
   point[0] = podoju[0]
elif n == 2 : #포도주 둘
  point[1] = podoju[0] + podoju[1]
else :  #포두주 셋 이상
  point[0] = podoju[0]
  point[1] = podoju[0] + podoju[1]
  point[2] = max(podoju[1]+podoju[2],podoju[0]+podoju[2], podoju[0] + podoju[1])
  for i in range(3, n) : 
    point[i] = max(point[i-1], podoju[i]+podoju[i-1]+point[i-3], podoju[i]+point[i-2])
    #i번 째 포도주를 마실 차례 일 때 1. i번째와 i-1번째를 마시고 i-3까지의 최댓값 or i번째를 마시고 i-2까지의 최댓값 or i번째를 안마시고 i-1까지의 최댓값

print(point[n-1])


#11053번 가장 긴 증가하는 부분 수열
n = int(input())
arr = []
arr = list(map(int,input().split()))

length = []
sub_arr = [[] for i in range(n)]
bigger_than_this = [[] for i in range(n)]
for i in range(n) : 
  sub_arr[0].append([arr[i]])
  bigger_than_this[0].append([i])


for i in range(n) : # i는 부분수열의 길이
  for j in range(len(sub_arr[i])) : # sub_arr[i][j]는 각 부분수열들
    for l in range(max(bigger_than_this[i][j]),n) : 
      if max(sub_arr[i][j]) < arr[l] : 
        sub_arr[i+1].append(sub_arr[i][j] + [arr[l]])
        bigger_than_this[i+1].append([l])
        length.append(len(sub_arr[i+1][-1]))

print(max(length))

#11053번 가장 긴 증가하는 부분 수열
n = int(input())
arr = []
arr = list(map(int,input().split()))
length = [1]*n

for i in range(n) : 
  for j in range(i,n) : 
    if arr[i] < arr[j] : 
      length[j] = max(length[i]+1,length[j])
print(length)
print(max(length))

#11054번 가장 긴 바이토닉 부분 수열
n = int(input())
arr_up = []
arr_down = []
arr_up = list(map(int,input().split())) #원래 수열 
arr_down = list(reversed(arr_up))  # 원래 수열을 뒤집음
length_up = [1]*n
length_down = [1]*n
length = []
for i in range(n) : 
  for j in range(i,n) : 
    if arr_up[i] < arr_up[j] : #원래 수열의 가장 긴 증가하는 부분 수열
      length_up[j] = max(length_up[i]+1,length_up[j])
    if arr_down[i] < arr_down[j] : #뒤집은 수열의 가장 긴 증가하는 부분 수열  == 원래 수열의 가장 긴 감소하는 부분 수열
      length_down[j] = max(length_down[i]+1, length_down[j])

for i in range(n) : 
  length.append(length_up[i] + list(reversed(length_down))[i]) # 각 인덱스마다 두 개 길이를 더해 줌

print(max(length)-1) # 인덱스는 중복되어 두번씩 세지기 때문에 하나를 뺌
