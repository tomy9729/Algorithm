# -*- coding: utf-8 -*-
"""백준 백트래킹

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/105YhPztsirL_dwPBvX4P77ZFIrsZ7BSp
"""

#15649번 N과 M(1)
n,m = input().split()
n = int(n)
m = int(m)

visit = [0]*(n+1)
arr = [0]*(m+1)

def is_not_duplicate(num) : 
  if visit[num] == 0 : 
    return True
  else : 
    return False

def check(x) :
  if x == m+1 : 
    for i in range(1,m+1) : 
      print(arr[i], end=' ')
    print()
  else : 
    for i in range(1,n+1) : 
      if is_not_duplicate(i) : 
        visit[i] = 1
        arr[x] = i
        check(x+1)
        arr[x] = 0
        visit[i] = 0

check(1)

#15650번 N과 M(2)
n,m = input().split()
n = int(n)
m = int(m)

arr = [0]*(m+1)

def check(x) :
  if x == m+1 : 
    for i in range(1,m+1) : 
      print(arr[i], end=' ')
    print()
  else : 
    for i in range(1,n+1) : 
      if max(arr) < i : 
        arr[x] = i
        check(x+1)
        arr[x] = 0

check(1)

#15651번 N과 M(3)
n,m = input().split()
n = int(n)
m = int(m)

arr = [0]*(m+1)

def check(x) :
  if x == m+1 : 
    for i in range(1,m+1) : 
      print(arr[i], end=' ')
    print()
  else : 
    for i in range(1,n+1) : 
      arr[x] = i
      check(x+1)
      arr[x] = 0

check(1)

#15652번 N과 M(4)
n,m = input().split()
n = int(n)
m = int(m)

arr = [0]*(m+1)

def check(x) :
  if x == m+1 : 
    for i in range(1,m+1) : 
      print(arr[i], end=' ')
    print()
  else : 
    for i in range(1,n+1) : 
      if max(arr) <= i : 
        arr[x] = i
        check(x+1)
        arr[x] = 0

check(1)

#9663번 N-Queen
n = int(input()) 
count = 0
arr = [0]*(n+1)
arr[0] = 100

def is_queen_no_die(arr, i) : # 새로 들어오는 퀸의 위치가 죽으면 False를 반환
  new_queen = arr.index(0)
  j = 1
  while arr[j] : #퀸이 존재하는 배열까지만 진행
    if arr[j] == i or abs(j - new_queen) == abs(arr[j] - i) : #퀸이 죽는 경우
      return False
    j += 1
  return True

def check(x) :
  if x == n+1 : 
    global count
    count += 1   
  else : 
    for i in range(1,n+1) :
      if x == 1 :  #첫 번째 퀸은 검사할 필요가 없음
        if n%2 == 0 and i > n//2 : # n이 짝수일때는 첫 번째 퀸을 반까지만 진행하고 나온 count값에 두배한다.
          break
        arr[x] = i
        check(x+1)
        arr[x] = 0
      elif is_queen_no_die(arr,i) : #퀸이 죽을 경우 수행하지 않음
        arr[x] = i
        check(x+1)
        arr[x] = 0

check(1)
if n%2 == 0 :
  print(count*2)
else : print(count)

#2580번 스도쿠
import sys
#input = sys.stdin.readline
board = [[0]*9 for i in range(9)]
for i in range(9) : 
  board[i][0],board[i][1],board[i][2],board[i][3],board[i][4],board[i][5],board[i][6],board[i][7],board[i][8] = map(int,input().split())

empty = [] #빈칸 좌표를 저장
for i in range(9) : 
  for j in range(9) :
    if board[i][j] == 0 : 
      empty.append([i,j])

def can_fill_empty(point, i) : #point는 빈칸의 좌표, i는 빈칸에 들어갈 숫자 
  if i in board[point[0]] : #행에 같은 숫자가 있으면 false
    return False
  for x in range(9) : 
    if board[x][point[1]] == i : #열에 같은 숫자가 있으면 false
      return False
  start_x = point[0]-(point[0]%3)
  start_y = point[1]-(point[1]%3)
  for x in range(start_x,start_x+3) : #정사각형에 같은 숫자가 있으면 false
    for y in range(start_y,start_y+3) : 
      if board[x][y] == i :
        return False
  return True

def check(x) :
  if x == len(empty) : #답 출력
    for i in range(9) : 
      for j in range(9) : 
        print(board[i][j],end=' ')
      print()
    sys.exit() #답을 한번만 출력하기위해 프로그램 강제 종료
  else : 
    for i in range(1,10) : 
      if can_fill_empty(empty[x],i): #빈칸을 채우는 조건에 만족하면.
        board[empty[x][0]][empty[x][1]] = i
        check(x+1)
        board[empty[x][0]][empty[x][1]] = 0

check(0)

#14888번 연산자 끼워넣기
import sys
input = sys.stdin.readline
n = int(input())
num = []
num = input().split()
for i in range(n) : 
  num[i] = int(num[i])

arr = [-1] * (n-1) # 연산자 기호들의 경우의 수를 그때그때 저장할 배열

operator = [0]*4
operator[0],operator[1],operator[2],operator[3] = map(int,input().split()) #순서대로 + - * /

all_operator = [] # 모든 연산자 기호들의 집합(중복 포함)
for i in range(4) : 
  for j in range(operator[i]) : 
    all_operator.append(i)
visit = [0]*len(all_operator) # 이미 사용된 기호를 구분하기 위함

def calculate(n1,n2,x) : # 연산자 계산기
  if x == 0 : 
    return n1+n2
  elif x == 1: 
    return n1-n2
  elif x == 2 :
    return n1*n2
  elif x == 3 :
    if n1 < 0 : 
      return -1*(-1*n1//n2)
    return n1//n2

def answer(num,arr) : # 완성된 식을 계산
  temp = num[0]
  for i in range(len(arr)) : 
    temp = calculate(temp,num[i+1],arr[i])
  return temp

answers = []
def check(x) :
  if x == n-1: # 끼워넣을 연산자 구성 완료
    answers.append(answer(num,arr))
  else : 
    for i in range(len(all_operator)) : 
      if visit[i] == 0 : # 중복 사용시 수행 x
        visit[i] = 1
        arr[x] = all_operator[i]
        check(x+1)
        arr[x] = -1
        visit[i] = 0

check(0)
print(max(answers))
print(min(answers))

#14889번 스타트와 링크
from itertools import combinations
n = int(input())
s = [[0]*n for i in range(n)]
for i in range(n) : 
  s[i] = list(map(int,input().split()))

team1 = [0]*n
team2 = [0]*n

answers = [] #정답들의 집합

all = list(combinations(range(1,n+1),n//2)) #가능한 모든 조합

def team_point(team) : 
  point = 0
  for i in team : 
    for j in team : 
      point += s[i-1][j-1]
  return point 

for i in range(len(all)//2) : # 조합들의 반까지만 진행하여 한팀에, 나머지 반은 남은 팀으로 배정
  team1 = all[i]
  team2 = all[len(all)-1-i]
  answers.append((abs(team_point(team1)-team_point(team2)))) # 정답들에 추가

print(min(answers)) # 가능한 정답 중 최솟값 출력
